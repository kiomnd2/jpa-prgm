## spring jpa 

## 목표
* JPA 내부 동작 방식을 이해하지 못하고 사용
* JPA 내부 동작 상식을 그림과 코드로 자세히 설명
* JPA가 어떤 SQL을 만들어 내는지 이해
* JPA가 언제 SQL을 실행하는지 이해


### 1. sql 중심적인 개발의 문제점
- 부한 반복, 지루한 코드..
    - (insert into,,, , update... select ,, )
- 객체 CRUD
    - 기능 추가시 객체와 sql 둘 다 수정

### 2. 객체 vs 관계형 DB 
*  관계형 DB
    * 상속, 즉 연관되있는 테이블간 조회시 쿼리와 객체의 맵핑이 복잡해짐
    * 객체는 참조를 사용 : member.getTeam()
    * 객체는 참조 관계가 한방향, 관계형은 양방향 참조 관계가 적용
    * 관계형 DB애서의 엔티티 신뢰문제 .. 
    * 모든 객체를 미리 조회 할 수 는 없다
    * 객체 조회시 같은 ID로 두개의 객체를 조회해서 같은 결과값을 낸다고 해도, 객체 주소값이 다르므로. 연산자 비교시 false 
* JPA
    * JPA는 애플링케이션과 JDBC 사이에서 동작
    * 적절한 엔티티 객체만 생성하여 JPA에 연산을 요청하면 내부적으로 쿼리를 생성하여 DB에 요청하여 결과를 반환받음
        * 패러다임의 불일치 해결
    * JPA는 인터페이스의 모음
        * 저장 : jpa.persist(member)
        * 조회 : Member member = jpa.find(memeberID);
        * 수정 : member.setName("변경할이름") 
        * 삭제 : jpa.remove(member)
    * 유지보수성이 우수
        * 데이터를 추가해야할 상황일 경우, sql에 손대지 않고 엔티티만 수정하여 해결가능
    * 데이터베이스에 구조에 대해 고민할 필요 없이 jpa의 인터페이스만 호출하면 요구사항에 맞는 쿼리를 수행해줌
    * 신뢰할 수 있는 엔티티, 계층
    * 동일한 트랜젝션에서 조회한 엔티티는 같음을 보장
    * JPA의 성능 최적화 기능
        1. 1차 캐시와 동일성 보장
        2. 트랜잭션을 지원하는 쓰기 지연 ( 버퍼링 기능 ..)
            - JDBC BATCH SQL 기능을 사용해 한번에 SQL 전송
        3. 지연 로딩
            - 객체가 실제 사용될 때 로딩

### 3. JPA

### 4. JPQL
* JPA를 사용하면 엔티티 객체를 중심으로 개발
* 문제는 검색 쿼리
* 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
* 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
* 애플리케이션이 필요한 데이터만  DB에서 불러오려면 결국 검색 조건이 포함된 SQL 이 필요
* JPA는 SQL을 추상화한 JPQL 이라는 객체지향 쿼리 언어 제공
* SQL과 문법 유사
* JPQL은 엔티티 객체를 대상으로 쿼리
* 객체지향 SQL..
